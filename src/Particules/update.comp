#version 460

#include "./common.glsl"

layout(local_size_x = 32) in;

layout(set = 0, binding = 0, std430) buffer readonly restrict b_previous_state
{
	Particule particules[];
} prev;

layout(set = 0, binding = 1, std430) buffer writeonly restrict b_next_state
{
	Particule particules[];
} next;

layout(set = 0, binding = 2) uniform ub_common_rules
{
	CommonRuleBuffer rules;
} ubo;

layout(push_constant) uniform constants
{
	uint number_of_particules;	
	float dt;
} _pc;

void main()
{
	const uint gid = gl_GlobalInvocationID.x;

	if(gid < _pc.number_of_particules)
	{
		const Particule p = prev.particules[gid];
		vec2 f = 0..xx;

		for(uint i = 0; i < _pc.number_of_particules; ++i)
		{
			if(i != gid)
			{
				const Particule o = prev.particules[i];
				const uint force_id = forceIndex(p, o);
				const ForceDescription force = ubo.rules.force_descriptions[force_id];
				f += computeForce(p, o, force);
			}
		}
		const float friction = -2e2;
		f += friction * p.velocity;
		const float mass = sqr(p.radius);

		Particule np = p;
		const float force_scale = 1e-6;
		const vec2 acc = (f * force_scale) / mass;
		np.velocity += acc * _pc.dt;
		np.position += np.velocity * _pc.dt;
		next.particules[gid] = np;
	}
}

