#version 460

#include "./common.glsl"

#define I_WANT_TO_DEBUG 1

#include <ShaderLib:/debugBuffers.glsl>

layout(local_size_x = 32) in;

layout(SHADER_DESCRIPTOR_BINDING + 0, std430) buffer readonly restrict b_previous_state
{
	Particule particules[];
} prev;

layout(SHADER_DESCRIPTOR_BINDING + 1, std430) buffer writeonly restrict b_next_state
{
	Particule particules[];
} next;

layout(SHADER_DESCRIPTOR_BINDING + 2, std430) buffer readonly restrict ub_common_rules
{
	CommonRuleBuffer rules;
} ubo;

layout(push_constant) uniform constants
{
	uint number_of_particules;	
	float dt;
	float friction;
	uint pad;
	vec3 world_size;
} _pc;

void main()
{
	const uint gid = gl_GlobalInvocationID.x;
#if DIMENSIONS == 2
	const vecD world_size = _pc.world_size.xy;
#elif DIMENSIONS == 3
	const vecD world_size = _pc.world_size.xyz;
#endif

	if(gid < _pc.number_of_particules)
	{
		const Particule p = prev.particules[gid];
		vecD f = vecD(0);

		for(uint i = 0; i < _pc.number_of_particules; ++i)
		{
			if(i != gid)
			{
				const Particule o = prev.particules[i];
				const uint force_id = forceIndex(p, o);
				const ForceDescription force = ubo.rules.force_descriptions[force_id];
				f += computeForce(p, o, force, world_size);
			}
		}
		const float force_scale = 1e-6;
		f *= force_scale;
		const vecD friction_force = _pc.friction * p.velocity;
		f -= friction_force;
		const float mass = sqr(p.radius);

		Particule np = p;
		const vecD acc = f / mass;
		vecD dv = acc * _pc.dt;
		dv = clamp(dv, -world_size*0.5, world_size*0.5);
		np.velocity += dv;
		np.position += (np.velocity * _pc.dt);
		np.position = modulatePosition(world_size * 0.5, world_size, np.position);
		next.particules[gid] = np;

		if(gid == 0)
		{
			Caret c = Caret2D(0..xx, 0);
			c = pushToDebugUVLn(world_size, c);
			c = pushToDebugUVLn(friction_force, c);
			c = pushToDebugUVLn(_pc.dt * 1e3 , c);
			c = pushToDebugUVLn(_pc.number_of_particules, c);
			
		}
	}
}

