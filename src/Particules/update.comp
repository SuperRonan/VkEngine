#version 460

#include "./common.glsl"

layout(local_size_x = 32) in;

layout(SHADER_DESCRIPTOR_BINDING + 0, std430) buffer readonly restrict b_previous_state
{
	Particule particules[];
} prev;

layout(SHADER_DESCRIPTOR_BINDING + 1, std430) buffer writeonly restrict b_next_state
{
	Particule particules[];
} next;

layout(SHADER_DESCRIPTOR_BINDING + 2, std430) buffer readonly restrict ub_common_rules
{
	CommonRuleBuffer rules;
} ubo;

layout(push_constant) uniform constants
{
	uint number_of_particules;	
	float dt;
	vec2 world_size;
	float friction;
} _pc;

void main()
{
	const uint gid = gl_GlobalInvocationID.x;
	const vec2 world_size = _pc.world_size;

	if(gid < _pc.number_of_particules)
	{
		const Particule p = prev.particules[gid];
		vec2 f = 0..xx;

		for(uint i = 0; i < _pc.number_of_particules; ++i)
		{
			if(i != gid)
			{
				const Particule o = prev.particules[i];
				const uint force_id = forceIndex(p, o);
				const ForceDescription force = ubo.rules.force_descriptions[force_id];
				f += computeForce(p, o, force, world_size);
			}
		}
		const float friction = 8e2 * _pc.friction;
		f -= friction * p.velocity;
		const float mass = sqr(p.radius);

		Particule np = p;
		const float force_scale = 1e-6;
		const vec2 acc = (f * force_scale) / mass;
		np.velocity += clamp(acc * _pc.dt, -world_size*0.5, world_size*0.5);
		np.velocity *= 0.1;
		np.position += np.velocity * _pc.dt;
		np.position = modulatePosition(world_size * 0.5, world_size, np.position);
		next.particules[gid] = np;
	}
}

