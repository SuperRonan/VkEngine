#version 460

#define I_WANT_TO_DEBUG 0
#define DEBUG_ENABLE_DEBUG_GLOBAL_SIGNAL 0
#include <ShaderLib:/Debug/DebugBuffers.glsl>

#include "../common.glsl"

#include <ShaderLib:/RayTracingCommon.glsl>

#define SHADING_SHADOW_METHOD SHADING_SHADOW_RAY_TRACE
#include "../shading.glsl"

#include <ShaderLib:/Maths/transforms.glsl>

layout(local_size_x = 16, local_size_y = 16) in;

layout(SHADER_DESCRIPTOR_BINDING + 1) uniform PT_UBO
{
	uint value;
} pt_ubo;

layout(SHADER_DESCRIPTOR_BINDING + 2, rgba32f) uniform restrict writeonly image2D Target;

layout(push_constant) uniform PushConstant
{
	uint value;
} _pc;

#define MAX_DEPTH 5
#define LIGHT_SAMPLES 16

struct PBMaterialData
{
	vec3 albedo;
	uint flags;
	float metallic;
	vec3 normal;
	float roughness;
	float cavity;
};

struct GeometryShadingInfo
{
	vec3 position;
	vec3 geometry_normal;
	vec3 vertex_shading_normal;
	vec3 shading_normal;
	vec3 shading_tangent;
};

PBMaterialData readMaterial(uint material_id, vec2 uv)
{
	const PBMaterialProperties props = scene_pb_materials[material_id].props;
	PBMaterialData res;
	res.flags = props.flags;
	res.albedo = 0..xxx;
	res.normal = vec3(0, 0, 1);
	const ScenePBMaterialTextures textures = scene_pb_materials_textures.ids[material_id];
	if(((res.flags & MATERIAL_FLAG_USE_ALBEDO_TEXTURE_BIT) != 0) && textures.albedo_texture_id != uint(-1))
	{
		res.albedo = texture(SceneTextures2D[textures.albedo_texture_id], uv).xyz;
	}
	else
	{
		res.albedo = props.albedo;
	}

	if(((res.flags & MATERIAL_FLAG_USE_NORMAL_TEXTURE_BIT) != 0) && textures.normal_texture_id != uint(-1))
	{
		res.normal = texture(SceneTextures2D[textures.normal_texture_id], uv).xyz;
		res.normal = normalize(res.normal * 2 - 1);
	}

	res.metallic = props.metallic;
	res.roughness = props.roughness;
	res.cavity = props.cavity;

	return res;
}


// wo: outcoming direction
// wi: incoming direction
// Assume directions vectors are normalized
vec3 evaluateBSDF(const in GeometryShadingInfo gsi, vec3 wo, vec3 wi, const in PBMaterialData material)
{
	vec3 res = 0..xxx;
	
	const vec3 geometry_normal = gsi.geometry_normal;
	const vec3 shading_normal = gsi.shading_normal;
	const vec3 normal = gsi.shading_normal;

	const float cos_theta_geom_i = dot(geometry_normal, wi);
	const float cos_theta_geom_o = dot(geometry_normal, wo);

	const float cos_theta_i = dot(normal, wi);
	const float abs_cos_theta_i = abs(cos_theta_i);
	const float cos_theta_o = dot(normal, wo);
	const float abs_cos_theta_o = abs(cos_theta_o);

	const bool same_hemisphere = sign(cos_theta_geom_i) == sign(cos_theta_geom_o);

	const bool can_reflect = (material.flags & MATERIAL_FLAG_REFLECTION_BIT) != 0;
	const bool can_transmit = (material.flags & MATERIAL_FLAG_TRANSMISSION_BIT) != 0;

	if((same_hemisphere && can_reflect) || (!same_hemisphere && can_transmit))
	{
		
		const vec3 reflected = reflect(-wo, normal);
		const vec3 halfway = normalize(wo + wi);

		const float alpha = sqr(material.roughness);
		const float alpha2 = sqr(alpha);
		const float specular_k = sqr(material.roughness + 1) / 8;

		const vec3 F0 = lerp(vec3(0.04), material.albedo, material.metallic);
		const vec3 specular_F = FresnelSchlick(F0, wo, halfway);
		const vec3 Kd = 1..xxx - specular_F; 

		const float diffuse_rho = oo_PI;
		const vec3 diffuse_contribution = Kd * material.albedo * diffuse_rho * (1.0 - material.metallic);
		res += diffuse_contribution;

		//const vec3 F0 = material.F0;

		if(nonZero(F0) && (material.roughness < 1.0f || material.metallic != 0.0f))
		{
			const float specular_D = microfacetD(alpha2, normal, halfway);
			const float specular_Go = microfacetGGX(normal, wo, specular_k);
			const float specular_Gi = microfacetGGX(normal, wi, specular_k);
			const float specular_G = specular_Go * specular_Gi; 

			const vec3 specular_cook_torrance = specular_F * specular_D * specular_G / max(4.0f * abs_cos_theta_i * abs_cos_theta_o, EPSILON_f);
			if(!any(isWrong(specular_cook_torrance)))
			{
				res += specular_cook_torrance;
			}
		}

	}

	return res;
}

struct BSDFSample
{
	vec3 direction;
	vec3 bsdf;
	float pdf;
};

BSDFSample sampleBSDF(const in GeometryShadingInfo gsi, vec3 wo, const in PBMaterialData material, inout rng_t rng)
{
	BSDFSample res;
	res.pdf = 1.0f;
	const vec3 normal = gsi.shading_normal;
	const mat3 local_to_world_basis = basisFromDir(normal);
	const vec3 reflected = reflect(-wo, normal);

	const float alpha = sqr(material.roughness);
	const float alpha2 = sqr(alpha);
	const float specular_k = sqr(material.roughness + 1) / 8;

	const vec3 F0 = lerp(vec3(0.04), material.albedo, material.metallic);
	bool sample_diffuse = true;
	if(material.roughness == 0)
	{
		const float dielectric_probability = material.metallic;
		const float dielectric_selection = randomFloat01(rng);
		if(dielectric_selection < dielectric_probability)
		{
			res.direction = reflected;
			res.pdf = dielectric_probability;
			res.bsdf = F0;
			sample_diffuse = false;
		}
		else
		{
			res.pdf = (1.0f - dielectric_probability);
		}
	}
	if(sample_diffuse)
	{
		const vec3 local_direction = randomCosineDirOnHemisphere(rng);
		res.direction = local_to_world_basis * local_direction;
		res.pdf *= local_direction.z / M_PI;
		res.bsdf = evaluateBSDF(gsi, wo, res.direction, material);
	}
	
	return res;
}

uint drawLight(inout rng_t rng, out float pdf)
{	
	pdf = 0;
	const uint num_lights = scene_ubo.num_lights;
	uint res = randomU32(rng) % num_lights;
	pdf = 1.0 / float(num_lights);
	return res;
}

// TODO add geometry normal
vec3 drawLightSample(const in GeometryShadingInfo vertex, vec3 wo, const in PBMaterialData material, inout rng_t rng)
{
	vec3 res = 0..xxx;
	float pdf = 0;
	const uint light_id = drawLight(rng, pdf);

	const vec3 normal = vertex.shading_normal;

	LightSample light_sample = getLightSample(light_id, vertex.position, normal, 0);
	pdf *= light_sample.pdf;
	if(pdf > 0 && nonZero(light_sample.Le))
	{
		const vec3 bsdf = evaluateBSDF(vertex, wo, light_sample.direction_to_light, material);
		const float cos_theta = abs(dot(light_sample.direction_to_light, vertex.shading_normal));
		res = light_sample.Le * bsdf * cos_theta / pdf;

		if(nonZero(res))
		{
			res *= computeShadow(vertex.position, normal, light_sample);
		}
	}

	return res;
}

Vertex transformVertex(mat4x3 matrix, mat3 dir_mat, Vertex v)
{
	Vertex res;
	res.position = matrix * vec4(v.position, 1);
	res.normal = dir_mat * v.normal;
	res.tangent = dir_mat * v.tangent;
	res.uv = v.uv;
	return res;
}

Vertex transformVertex(mat4x3 matrix, Vertex v)
{
	return transformVertex(matrix, directionMatrix(mat3(matrix)), v);
}

Vertex normalize(Vertex v)
{
	v.normal = normalize(v.normal);
	v.tangent = normalize(v.tangent);
	return v;
}



vec3 trace(Ray ray, inout rng_t rng)
{
	vec3 res = 0..xxx;
	RayQuery_t rq;
	const uint ray_flags = gl_RayFlagsSkipAABBEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
	const uint cull_mask = 0xFF;
	vec2 range = vec2(0, 1000);

	vec3 throughput = 1..xxx;

	int depth = 0;
	while(depth < MAX_DEPTH)
	{
		rayQueryInitializeEXT(rq, SceneTLAS, ray_flags, cull_mask, ray.origin, range.x, ray.direction, range.y);
		rayQueryProceedEXT(rq);		

		if(rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionNoneEXT)
		{
			break;
		}
		else
		{
			const vec3 wo = -ray.direction;

			const uint custom_index = rayQueryGetIntersectionInstanceCustomIndexEXT(rq, true);
			const uint instance_index = rayQueryGetIntersectionInstanceIdEXT(rq, true);
			const uint sbt_index = rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT(rq, true);
			const uint geometry_index = rayQueryGetIntersectionGeometryIndexEXT(rq, true);
			const uint object_index = custom_index;
			const int primitive_id = rayQueryGetIntersectionPrimitiveIndexEXT(rq, true);
			const vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rq, true);
			const mat4x3 object_to_world = rayQueryGetIntersectionObjectToWorldEXT(rq, true);
			const mat3 object_to_world_4dir = directionMatrix(mat3(object_to_world));

			SceneObjectReference hit_object_ref = scene_objects_table.table[object_index];
			
			const MeshHeader mesh_header = scene_mesh_headers[hit_object_ref.mesh_id].headers;
			const uvec3 vertices_id = getSceneMeshTriangleVerticexIndices(hit_object_ref.mesh_id, primitive_id, mesh_header.flags);
#if SHADER_RAY_TRACING_POSITION_FETCH_AVAILABLE && 0
			const mat3 triangle_positions = GetQueryIntersectionTriangleVertexPositionsCommitted(rq);
#else 
			const mat3 triangle_positions = readSceneTriangleVertexPositions(hit_object_ref.mesh_id, vertices_id);
#endif
			const vec3 geometry_normal_object = computeTriangleNormal(triangle_positions);
			const vec3 geometry_normal_world = normalize(object_to_world_4dir * geometry_normal_object);
			const Vertex vertex = interpolateSceneVertex(hit_object_ref.mesh_id, vertices_id, barycentrics);
			const Vertex world_vertex = normalize(transformVertex(object_to_world, vertex));
			
			GeometryShadingInfo gsi;
			gsi.position = world_vertex.position;
			gsi.geometry_normal = geometry_normal_world;
			gsi.vertex_shading_normal = world_vertex.normal;
			gsi.shading_tangent = world_vertex.tangent;
			const vec3 shading_bt = cross(gsi.shading_tangent, gsi.vertex_shading_normal);
			const mat3 shading_TBN = mat3(gsi.shading_tangent, shading_bt, gsi.vertex_shading_normal);
			PBMaterialData material = readMaterial(hit_object_ref.material_id, vertex.uv);
			gsi.shading_normal = shading_TBN * material.normal;
			//gsi.shading_normal = gsi.vertex_shading_normal;
			

			vec3 light_samples = 0..xxx;
			for(uint l = 0; l < LIGHT_SAMPLES; ++l)
			{
				light_samples += drawLightSample(gsi, wo, material, rng);
			}
			res += throughput * (light_samples / LIGHT_SAMPLES);

			if(depth < (MAX_DEPTH - 1))
			{
				BSDFSample bsdf_sample = sampleBSDF(gsi, wo, material, rng);
				if(bsdf_sample.pdf > 0)
				{
					vec3 next_dir_world = bsdf_sample.direction;
					ray.origin = gsi.position;
					ray.direction = next_dir_world;
					range.x = rayTMin(ray, geometry_normal_world);

					const float cos_theta = abs(dot(gsi.shading_normal, ray.direction));

					throughput *= (bsdf_sample.bsdf * cos_theta / bsdf_sample.pdf);
				}
				else
				{
					throughput*= 0; 	
				}
				
			}

			if(!nonZero(throughput))
			{
				break;
			}
		}
		++depth;
	}
	return res;
}


void main()
{
	const uvec2 gid = uvec2(gl_GlobalInvocationID.xy);
	const uvec2 pixel = gid;
	const uvec2 dims = imageSize(Target);
	const vec2 oo_dims = rcp(dims);
	if(all(lessThan(pixel, dims)))
	{

		rng_t rng = hash(pixel) ^ hash(ubo.frame_idx);
		vec3 res = 0..xxx;
		const vec2 subpixel_uv = lerp(0.1.xx, 0.9.xx, randomVec2_01(rng));
		//const vec2 subpixel_uv = 0.5.xx;
		const vec2 uv = (vec2(pixel) + subpixel_uv) * oo_dims;

		const mat4 w2p = ubo.world_to_proj;
		const mat4 p2c = inverse(ubo.camera_to_proj);
		const mat4 c2w = inverse(ubo.world_to_camera);
		const mat3 c2w_dir = inverse(mat3(ubo.world_to_camera));
		const mat4 p2w = inverse(w2p);
		
		const vec4 camera_pos_h = inverse(ubo.world_to_camera) * vec4(0, 0, 0, 1);
		const vec3 camera_pos = camera_pos_h.xyz / camera_pos_h.w; 

		vec4 dir_h = normalize(p2c * vec4(UVToClipSpace(uv), 1, 1));
		dir_h.xyz = c2w_dir * dir_h.xyz;

		Ray ray = Ray(camera_pos, dir_h.xyz);


		res = trace(ray, rng);
		
		//res = subpixel_uv.xyx;

		imageStore(Target, ivec2(pixel), vec4(res, 1));
	}
}