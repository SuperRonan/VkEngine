#version 460

#define I_WANT_TO_DEBUG 0
#define DEBUG_ENABLE_DEBUG_GLOBAL_SIGNAL 0
#include <ShaderLib:/Debug/DebugBuffers.glsl>

#include "../common.glsl"

#include <ShaderLib:/RayTracingCommon.glsl>

#define SHADING_SHADOW_METHOD SHADING_SHADOW_RAY_TRACE
#include "../shading.glsl"

#include <ShaderLib:/Maths/transforms.glsl>

layout(local_size_x = 16, local_size_y = 16) in;

layout(SHADER_DESCRIPTOR_BINDING + 1) uniform PT_UBO
{
	uint value;
} pt_ubo;

layout(SHADER_DESCRIPTOR_BINDING + 2, rgba32f) uniform restrict writeonly image2D Target;

layout(push_constant) uniform PushConstant
{
	uint value;
} _pc;

#define MAX_DEPTH 5
#define LIGHT_SAMPLES 16

struct BSDFSample
{
	vec3 direction;
	vec3 bsdf;
	float pdf;
};

BSDFSample sampleBSDF(const in GeometryShadingInfo gsi, vec3 wo, const in PBMaterialData material, inout rng_t rng)
{
	BSDFSample res;
	res.pdf = 1.0f;
	const vec3 normal = gsi.shading_normal;
	const mat3 local_to_world_basis = basisFromDir(normal);
	const vec3 reflected = reflect(-wo, normal);

	const float alpha = sqr(material.roughness);
	const float alpha2 = sqr(alpha);
	const float specular_k = sqr(material.roughness + 1) / 8;

	const vec3 F0 = lerp(vec3(0.04), material.albedo, material.metallic);
	bool sample_diffuse = true;
	if(material.roughness == 0)
	{
		const float dielectric_probability = material.metallic;
		const float dielectric_selection = randomFloat01(rng);
		if(dielectric_selection < dielectric_probability)
		{
			res.direction = reflected;
			res.pdf = dielectric_probability;
			res.bsdf = F0;
			sample_diffuse = false;
		}
		else
		{
			res.pdf = (1.0f - dielectric_probability);
		}
	}
	if(sample_diffuse)
	{
		const vec3 local_direction = randomCosineDirOnHemisphere(rng);
		res.direction = local_to_world_basis * local_direction;
		res.pdf *= local_direction.z / M_PI;
		res.bsdf = evaluateBSDF(gsi, wo, res.direction, material);
	}
	
	return res;
}

uint drawLight(inout rng_t rng, out float pdf)
{	
	pdf = 0;
	const uint num_lights = scene_ubo.num_lights;
	uint res = randomU32(rng) % num_lights;
	pdf = 1.0 / float(num_lights);
	return res;
}

// TODO add geometry normal
vec3 drawLightSample(const in GeometryShadingInfo vertex, vec3 wo, const in PBMaterialData material, inout rng_t rng)
{
	vec3 res = 0..xxx;
	float pdf = 0;
	const uint light_id = drawLight(rng, pdf);

	const vec3 normal = vertex.shading_normal;

	LightSample light_sample = getLightSample(light_id, vertex.position, normal, 0);
	pdf *= light_sample.pdf;
	if(pdf > 0 && nonZero(light_sample.Le))
	{
		const vec3 bsdf = evaluateBSDF(vertex, wo, light_sample.direction_to_light, material);
		const float cos_theta = abs(dot(light_sample.direction_to_light, vertex.shading_normal));
		res = light_sample.Le * bsdf * cos_theta / pdf;

		if(nonZero(res))
		{
			res *= computeShadow(vertex.position, normal, light_sample);
		}
	}

	return res;
}

Vertex transformVertex(mat4x3 matrix, mat3 dir_mat, Vertex v)
{
	Vertex res;
	res.position = matrix * vec4(v.position, 1);
	res.normal = dir_mat * v.normal;
	res.tangent = dir_mat * v.tangent;
	res.uv = v.uv;
	return res;
}

Vertex transformVertex(mat4x3 matrix, Vertex v)
{
	return transformVertex(matrix, directionMatrix(mat3(matrix)), v);
}

Vertex normalize(Vertex v)
{
	v.normal = normalize(v.normal);
	v.tangent = normalize(v.tangent);
	return v;
}



vec3 trace(Ray ray, inout rng_t rng)
{
	vec3 res = 0..xxx;
	RayQuery_t rq;
	const uint ray_flags = gl_RayFlagsSkipAABBEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
	const uint cull_mask = 0xFF;
	vec2 range = vec2(0, 1000);

	vec3 throughput = 1..xxx;

	int depth = 0;
	while(depth < MAX_DEPTH)
	{
		rayQueryInitializeEXT(rq, SceneTLAS, ray_flags, cull_mask, ray.origin, range.x, ray.direction, range.y);
		rayQueryProceedEXT(rq);		

		if(rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionNoneEXT)
		{
			break;
		}
		else
		{
			const vec3 wo = -ray.direction;

			const uint custom_index = rayQueryGetIntersectionInstanceCustomIndexEXT(rq, true);
			const uint instance_index = rayQueryGetIntersectionInstanceIdEXT(rq, true);
			const uint sbt_index = rayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetEXT(rq, true);
			const uint geometry_index = rayQueryGetIntersectionGeometryIndexEXT(rq, true);
			const uint object_index = custom_index;
			const int primitive_id = rayQueryGetIntersectionPrimitiveIndexEXT(rq, true);
			const vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rq, true);
			const mat4x3 object_to_world = rayQueryGetIntersectionObjectToWorldEXT(rq, true);
			const mat3 object_to_world_4dir = directionMatrix(mat3(object_to_world));

			SceneObjectReference hit_object_ref = scene_objects_table.table[object_index];
			
			const MeshHeader mesh_header = scene_mesh_headers[hit_object_ref.mesh_id].headers;
			const uvec3 vertices_id = getSceneMeshTriangleVerticexIndices(hit_object_ref.mesh_id, primitive_id, mesh_header.flags);
#if SHADER_RAY_TRACING_POSITION_FETCH_AVAILABLE && 0
			const mat3 triangle_positions = GetQueryIntersectionTriangleVertexPositionsCommitted(rq);
#else 
			const mat3 triangle_positions = readSceneTriangleVertexPositions(hit_object_ref.mesh_id, vertices_id);
#endif
			const vec3 geometry_normal_object = computeTriangleNormal(triangle_positions);
			const vec3 geometry_normal_world = normalize(object_to_world_4dir * geometry_normal_object);
			const Vertex vertex = interpolateSceneVertex(hit_object_ref.mesh_id, vertices_id, barycentrics);
			const Vertex world_vertex = normalize(transformVertex(object_to_world, vertex));
			
			GeometryShadingInfo gsi;
			gsi.position = world_vertex.position;
			gsi.geometry_normal = geometry_normal_world;
			gsi.vertex_shading_normal = world_vertex.normal;
			gsi.shading_tangent = world_vertex.tangent;
			const vec3 shading_bt = cross(gsi.shading_tangent, gsi.vertex_shading_normal);
			const mat3 shading_TBN = mat3(gsi.shading_tangent, shading_bt, gsi.vertex_shading_normal);
			PBMaterialData material = readMaterial(hit_object_ref.material_id, vertex.uv);
			gsi.shading_normal = shading_TBN * material.normal;
			//gsi.shading_normal = gsi.vertex_shading_normal;
			

			vec3 light_samples = 0..xxx;
			for(uint l = 0; l < LIGHT_SAMPLES; ++l)
			{
				light_samples += drawLightSample(gsi, wo, material, rng);
			}
			res += throughput * (light_samples / LIGHT_SAMPLES);

			if(depth < (MAX_DEPTH - 1))
			{
				BSDFSample bsdf_sample = sampleBSDF(gsi, wo, material, rng);
				if(bsdf_sample.pdf > 0)
				{
					vec3 next_dir_world = bsdf_sample.direction;
					ray.origin = gsi.position;
					ray.direction = next_dir_world;
					range.x = rayTMin(ray, geometry_normal_world);

					const float cos_theta = abs(dot(gsi.shading_normal, ray.direction));

					throughput *= (bsdf_sample.bsdf * cos_theta / bsdf_sample.pdf);
				}
				else
				{
					throughput*= 0; 	
				}
				
			}

			if(!nonZero(throughput))
			{
				break;
			}
		}
		++depth;
	}
	return res;
}


void main()
{
	const uvec2 gid = uvec2(gl_GlobalInvocationID.xy);
	const uvec2 pixel = gid;
	const uvec2 dims = imageSize(Target);
	const vec2 oo_dims = rcp(dims);
	if(all(lessThan(pixel, dims)))
	{

		rng_t rng = hash(pixel) ^ hash(ubo.frame_idx);
		vec3 res = 0..xxx;
		const vec2 subpixel_uv = lerp(0.1.xx, 0.9.xx, randomVec2_01(rng));
		//const vec2 subpixel_uv = 0.5.xx;
		const vec2 uv = (vec2(pixel) + subpixel_uv) * oo_dims;

		const mat4 w2p = ubo.world_to_proj;
		const mat4 p2c = inverse(ubo.camera_to_proj);
		const mat4 c2w = inverse(ubo.world_to_camera);
		const mat3 c2w_dir = inverse(mat3(ubo.world_to_camera));
		const mat4 p2w = inverse(w2p);
		
		const vec4 camera_pos_h = inverse(ubo.world_to_camera) * vec4(0, 0, 0, 1);
		const vec3 camera_pos = camera_pos_h.xyz / camera_pos_h.w; 

		vec4 dir_h = normalize(p2c * vec4(UVToClipSpace(uv), 1, 1));
		dir_h.xyz = c2w_dir * dir_h.xyz;

		Ray ray = Ray(camera_pos, dir_h.xyz);


		res = trace(ray, rng);
		
		//res = subpixel_uv.xyx;

		imageStore(Target, ivec2(pixel), vec4(res, 1));
	}
}