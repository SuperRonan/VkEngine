#pragma once

// Khronos spec:	https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.html
// Nanocolor lib: 	https://github.com/meshula/Nanocolor/tree/main
// VkColorSpaceKHR: https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkColorSpaceKHR.html

// Transfer functions
// OETF(x): Conversion from normalized linear light intensity of the scene (e.g. what a rendering engine should output, normalized because it might be pre-multiplied by an exposure factor) to a non linear electronic representation (to be encoded, like sRGB)
// EOTF(x): Conversion from a non linear electronic representation (decoded from sRGB) to a linear light intensity of the display (what light the screen produces)
// OOTF(x) = EOTF(OETF(x)) Conversion from the linear light intensity of the scene to the display linear light
// In some cases OETF and EOTF are perfect inverse of each other, and thus OOTF is the identity function.
// These transfer functions work with real numbers and do not include encoding or decoding (So even if EOTF and OETF are perfect inverse, OOTF is supposed to be a true Id, but because of the intermediate encoding / decoding step, there might be quantization / clamps)

// In practice, when color correcting the frame generated by the renderer to be displayed by the swapchain in a certain color space, we need to apply the OETF.
// There is just the case of sRGB formats, where the transfer function is applied by the hardware
// Most transfer functions apply the same transformation to each R, G and B channel. 

enum DataFormatKHR
{
	// No transfer function defined
	UNSPECIFIED =  0,
	// Linear transfer function (value proportional to intensity)
	LINEAR =       1,
	// Perceptually-linear transfer function of sRGH (~2.4)
	SRGB =         2,
	// Perceptually-linear transfer function of ITU non-HDR specifications (~1/.45)
	ITU =          3,
	// SMTPE170M (digital NTSC) defines an alias for the ITU transfer function (~1/.45)
	SMTPE170M =    3,
	// Perceptually-linear gamma function of original NTSC (simple 2.2 gamma)
	NTSC =         4,
	// Sony S-log used by Sony video cameras
	SLOG =         5,
	// Sony S-log 2 used by Sony video cameras
	SLOG2 =        6,
	// ITU BT.1886 EOTF
	BT1886 =       7,
	// ITU BT.2100 HLG OETF
	HLG_OETF =     8,
	// ITU BT.2100 HLG EOTF
	HLG_EOTF =     9,
	// ITU BT.2100 PQ EOTF
	PQ_EOTF =      10,
	// ITU BT.2100 PQ OETF
	PQ_OETF =      11,
	// DCI P3 transfer function
	DCIP3 =        12,
	// Legacy PAL OETF
	PAL_OETF =     13,
	// Legacy PAL 625-line EOTF
	PAL625_EOTF =  14,
	// Legacy ST240 transfer function
	ST240 =        15,
	// ACEScc transfer function
	ACESCC =       16,
	// ACEScct transfer function
	ACESCCT =      17,
	// Adobe RGB (1998) transfer function
	ADOBERGB =     18,
};

enum TransferFunction
{
	None = 0,
	Id = None,
	ITU 		= None + 1,
	sRGB 		= ITU + 1,
	scRGB 		= sRGB + 1,
	BT1886 		= scRGB + 1,
	HLG 		= BT1886 + 1,
	PQ 			= HLG + 1,
	DisplayP3	= PQ + 1, // in RGB
	DCI_P3 		= DisplayP3 + 1, // in XYZ
	Legacy_NTSC = DCI_P3 + 1,
	Legacy_PAL 	= Legacy_NTSC + 1,
	ST240 		= Legacy_PAL + 1,
	AdobeRGB 	= ST240 + 1,
	Sony_SLog 	= AdobeRGB + 1,
	Sony_SLog2 	= Sony_SLog + 1,
	ACEScc 		= Sony_SLog2 + 1,
	ACEScct 	= ACEScc + 1,
	Gamma		= ACEScct + 1,
};

float RectifiedGammaTF(float linear_value, float gamma, float lambda, float beta, float alpha)
{
	if(linear_value <= beta)	return linear_value * lambda;
	else						return (1 + alpha) * pow(linear_value, gamma) - alpha;
}

float RectifiedGammaBetaConstant(float gamma, float lambda, const uint iterations)
{
	// Solve with Newton's tf, should be constexpr
	// Equation: 0 = b * (1 - rcp(g)) + rcp(g) * pow(b, 1 - g) - rcp(l)
	// Derivative: (1 - rcp(g)) * (1 - pow(b, -g))
	float beta = 0.5 * pow(rcp(lambda), rcp(1-gamma));
	const float rg = rcp(gamma);
	for(uint i = 0; i < iterations; ++i)
	{
		const float f = beta * (1 - rg) + rg * pow(beta, 1 - gamma) - rcp(lambda);
		const float df = (1 - rg) * (1 - pow(beta, -gamma));
		beta -= f / df;
	}
	return beta;
}

float RectifiedGammaBetaConstant(float gamma, float lambda)
{
	return RectifiedGammaBetaConstant(gamma, lambda, 4);
}

float RectifiedGammaAlphaConstant(float gamma, float lambda, float beta)
{
	return lambda * rcp(gamma) * pow(beta, 1 - gamma) - 1;
}

float RectifiedGammaDeltaConstant(float lambda, float beta)
{
	return lambda * beta;
}

float RectifiedGammaTF(float linear_value, float gamma, float lambda, float beta)
{
	const float alpha = RectifiedGammaAlphaConstant(gamma, lambda, beta);
	return RectifiedGammaTF(linear_value, gamma, lambda, beta, alpha);
}

float RectifiedGammaTF(float linear_value, float gamma, float lambda)
{
	const float beta = RectifiedGammaBetaConstant(gamma, lambda);
	return RectifiedGammaTF(linear_value, gamma, lambda, beta);
}

float ITU_OETF(float l)
{
	return RectifiedGammaTF(l, 0.45, 4.5);//, 0.018053968510808);
}

float sRGB_OETF(float l)
{
	const float gamma = rcp(2.4);
	const float lambda = 12.92;
	const float beta = RectifiedGammaBetaConstant(gamma, lambda);
	//const float beta = 0.003041282560128;
	const float alpha = RectifiedGammaAlphaConstant(gamma, lambda, beta);// 0.05501;
	//return l <= beta ? lambda * l : ((1 + alpha) * pow(l, gamma) - alpha);
	return RectifiedGammaTF(l, gamma, lambda);
}

float scRGB_OETF(float l)
{
	return sign(l) * sRGB_OETF(abs(l));
}

// l in [0, 1]
// for BT.2100-1 and BT.2100-2 (BT.2100-0 uses other constants)
float HLG_Normalized_OETF(float l)
{
	const float a = 0.17883277;
	const float b = 1 - 4 * a;
	const float c = 0.5 - a * log(4 * a);
	return (l <= rcp(12.0)) ? (sqrt(3 * l)) : (a * log(12 * l - b) + c);
}

float HLG_OETF(float l)
{
	return HLG_Normalized_OETF(l);
}

// l in [0, 12]
float HLG_UnNormalized_OETF(float l)
{
	return HLG_Normalized_OETF(l / 12.0f);
}

float PQ_OETF(float l);

float FitPQ_Gamma_Linear(float exposure)
{
	const float alpha = 0.005182;
	const float beta = 3.333;
	const float gamma = alpha * exposure + beta;
	return gamma;
}

float FitPQGamma_Pow(float exposure)
{	
	const float a = 2.543;
	const float b = 0.1204;
	const float c = 0;
	
	// const float a = 1.39364;
	// const float b = 0.175651;
	// const float c = 1.23851;
	
	const float gamma = a * pow(exposure, b) + c;
	return gamma;
}

// Assume l is pre mult by exposure
float PQ_FitWithGamma_OETF(float l, float exposure)
{
	// Approx linear fit of gamma depending on exposure
	const float e = PQ_OETF(exposure);
	const float gamma = FitPQGamma_Pow(exposure);
	return e * pow(l / exposure, rcp(gamma));
}

// l in [0, 1]
float PQ_OETF(float l)
{
	const float m1 = 1305.0 / 8192.0;
	const float m2 = 2523.0 / 32.0;
	const float c1 = 107.0 / 128.0;
	const float c2 = 2413.0 / 128.0;
	const float c3 = 2392.0 / 128.0;
	const float Y = l * rcp(10000.0);
	const float Ym1 = pow(Y, m1);
	return pow((c1 + c2 * Ym1) / (1 + c3 * Ym1), m2);
}

float DisplayP3_OETF(float l)
{
	return sRGB_OETF(l);
}

float DCI_P3_OETF(float l)
{
	const float gamma = 2.6;
	return pow(l / 52.37, rcp(gamma));
}

float Gamma_OETF(float l, float gamma)
{
	return pow(l, gamma);
}

float OETF(float l, TransferFunction tf)
{
	float res = l;
	if(tf == TransferFunction::ITU)
		res = ITU_OETF(l);
	else if(tf == TransferFunction::sRGB)
		res = sRGB_OETF(l);
	else if(tf == TransferFunction::scRGB)
		res = scRGB_OETF(l);
	// else if(tf == TransferFunction::BT1886)
	// 	res = BT1886_OETF(l);
	else if(tf == TransferFunction::HLG)
		res = HLG_OETF(l);
	else if(tf == TransferFunction::PQ)
		res = PQ_OETF(l);
	else if (tf == TransferFunction::DisplayP3)
		res = DisplayP3_OETF(l);
	else if(tf == TransferFunction::DCI_P3)
		res = DCI_P3_OETF(l);
	return res;
}

float OETF(float l, TransferFunction tf, float gamma)
{
	float res = l;
	if(tf == TransferFunction::Gamma)
	{
		res = Gamma_OETF(l, gamma);
	}
	else
	{
		res = OETF(l, tf);
	}
	return res;
}

float3 OETF(float3 linear_rgb, TransferFunction tf, float gamma)
{
	float3 res;
	for(uint i = 0; i < 3; ++i)
	{
		res[i] = OETF(linear_rgb[i], tf, gamma);
	}
	return res;
}

// The Alpha channel is passed through
float4 OETF(float4 linear_rgb_alpha, TransferFunction tf, float gamma)
{
	return float4(OETF(linear_rgb_alpha.rgb, tf, gamma), linear_rgb_alpha.a);
}



